# Plan: Track MCP Servers in Workflow Manifests

## Problem

Hugo tracks what each installed workflow provides — agents, commands, and skills — via `workflow.json` manifests and cached state in `opencode.json`. This powers `hugo ls`, `hugo health`, and collision detection.

Workflow plugins can also register MCP servers via the `config` hook, but Hugo has no visibility into these. `hugo ls` doesn't show MCP servers. Users have no way to see which workflow is providing which MCP server without reading the plugin source code.

## Background

### How MCPs work in OpenCode

MCP servers are configured in `opencode.json` under the `mcp` key as declarative JSON objects:

```json
{
  "mcp": {
    "context7": {
      "type": "remote",
      "url": "https://mcp.context7.com/mcp",
      "headers": {
        "CONTEXT7_API_KEY": "{env:CONTEXT7_API_KEY}"
      }
    }
  }
}
```

Two types: `remote` (URL + optional headers/OAuth) and `local` (command array + optional env vars). OpenCode supports `{env:VARIABLE_NAME}` substitution at runtime, so no secrets need to be stored in config files.

Users add MCPs directly to `opencode.json`. Plugins add MCPs programmatically via the `config` hook:

```typescript
export const MyPlugin: Plugin = async (ctx) => ({
  config: async (config) => {
    config.mcp = { ...myMcps, ...config.mcp }; // user config takes precedence
  },
});
```

### How workflows register MCPs

Every workflow Hugo installs is an OpenCode plugin — it goes into the `plugin` array, OpenCode loads it, and its `config` hook runs at startup. MCPs are registered in that hook alongside agents, commands, and skills. The workflow's plugin entry point is the single place where all registration happens.

### What Hugo tracks today

`workflow.json` (generated by `hugo build`):
```json
{ "agents": ["reviewer"], "commands": ["review"], "skills": ["analysis"] }
```

`hugo.workflows` state (cached in `opencode.json` at install time):
```json
{
  "code-review": {
    "package": "@org/code-review",
    "version": "1.0.0",
    "agents": ["reviewer"],
    "commands": ["review"],
    "skills": ["analysis"]
  }
}
```

MCPs are absent from both.

### Why MCPs don't need collision detection

Unlike agents, commands, and skills — where a naming collision means one silently shadows another and changes AI behavior — MCP servers are merged into a flat `config.mcp` object. If two workflows both register `context7`, they're almost certainly pointing at the same canonical service. Even when configurations differ, the behavior is observable (the MCP either connects or doesn't), and the merge semantics are well-defined: user config takes precedence, then plugin load order.

Collision detection for MCPs would produce noisy warnings for a benign situation (two workflows both wanting to provide the same well-known MCP). The existing collision detection in `collisions.ts` is unchanged by this plan.

## Goal

Add `mcps` to `workflow.json` manifests and Hugo's cached state so that:

1. `hugo ls` displays which MCP servers each workflow provides
2. `hugo build` detects and records MCP server registrations
3. MCP visibility is maintained through the install -> update -> list lifecycle

## Design

### Detection strategy: execute the plugin function at build time

Workflow authors define MCPs in different ways — TypeScript objects, imported JSON files, factory functions — but they always register them through the plugin's `config` hook. Rather than imposing a directory convention or requiring manual declaration, `hugo build` executes the plugin function with a mock context and inspects what the `config` hook writes to `config.mcp`.

```typescript
async function detectMcps(
  projectDir: string,
  pkg: Record<string, unknown>,
): Promise<string[]> {
  // 1. Resolve source entry point
  //    pkg.main / pkg.module typically point to compiled output (e.g. dist/index.js)
  //    which doesn't exist at build time. Look for source files instead.
  const entryPath = await resolveSourceEntry(projectDir, pkg);
  if (!entryPath) return [];

  // 2. Dynamic import (bun handles TypeScript natively)
  //    Cache-bust to prevent stale modules when build is run multiple times
  //    in the same process (e.g. in tests).
  const mod = await import(entryPath + "?t=" + Date.now());

  // 3. Find the exported Plugin (factory function or pre-built hooks object)
  //    Resolution order for factories:
  //      a. Default export, if it's a function
  //      b. If exactly one exported function exists, use it
  //      c. If multiple, pick the first whose name ends with "Plugin" (case-insensitive)
  //    Fallback for hooks objects:
  //      d. Default export, if it has a `config` function property
  //      e. If exactly one export has a `config` function, use it
  //      f. Otherwise give up — can't disambiguate
  const pluginExport = resolvePluginExport(mod);
  if (!pluginExport) return [];

  // 4. Get the hooks object — either by calling the factory or using directly
  let hooks: Record<string, unknown>;

  if (pluginExport.kind === "factory") {
    //    Deep proxy traps give clear errors if the plugin actually uses the SDK,
    //    even for chained access like ctx.client.api.listTools().
    //    All PluginInput fields are present — serverUrl and project use deep proxies
    //    so any access produces a clear error rather than an undefined crash.
    hooks = await pluginExport.fn({
      client: buildDeepProxy("SDK not available during build"),
      project: buildDeepProxy("Project context not available during build"),
      directory: projectDir,
      worktree: projectDir,
      serverUrl: new URL("http://localhost:0"),
      $: buildDeepProxy("Shell not available during build"),
    });
  } else {
    // Already a hooks object — use directly, no mock context needed
    hooks = pluginExport.hooks;
  }

  // 5. Call the config hook with an empty object and read what it wrote
  //    The config hook's type signature is (input: Config) => Promise<void>,
  //    where Config is a strongly-typed SDK object. We pass a plain object,
  //    which works because plugins mutate properties on it at runtime — the
  //    structural typing is compatible even though the compile-time types differ.
  if (!hooks?.config) return [];
  if (typeof hooks.config !== "function") return [];

  const mockConfig: Record<string, unknown> = {};
  await hooks.config(mockConfig);

  if (mockConfig.mcp && typeof mockConfig.mcp === "object" && !Array.isArray(mockConfig.mcp)) {
    return Object.keys(mockConfig.mcp as Record<string, unknown>).sort();
  }

  return [];
}
```

#### Source entry point resolution

`pkg.main` and `pkg.module` typically point to compiled output (e.g. `dist/index.js`) that doesn't exist when `hugo build` runs in the source directory. Instead, we probe for actual source files:

```typescript
async function resolveSourceEntry(
  projectDir: string,
  pkg: Record<string, unknown>,
): Promise<string | null> {
  // Explicit source field takes priority
  if (typeof pkg.source === "string") {
    const p = join(projectDir, pkg.source);
    if (await fileExists(p)) return p;
  }

  // package.json "exports" field — the modern standard for entry points.
  // Handles: string shorthand, or object with "bun"/"import"/"default" conditions.
  const exportsEntry = resolveExportsEntry(pkg);
  if (exportsEntry) {
    const p = join(projectDir, exportsEntry);
    if (await fileExists(p)) return p;
  }

  // Common source entry points
  for (const candidate of ["index.ts", "src/index.ts"]) {
    const p = join(projectDir, candidate);
    if (await fileExists(p)) return p;
  }

  // Fall back to main/module — may work if the author uses .ts directly
  for (const field of ["main", "module"]) {
    if (typeof pkg[field] === "string") {
      const p = join(projectDir, pkg[field] as string);
      if (await fileExists(p)) return p;
    }
  }

  return null;
}

/**
 * Extract the "." entry point from the package.json "exports" field.
 * Supports:
 *   - String shorthand: "exports": "./src/index.ts"
 *   - Condition object:  "exports": { ".": { "bun": "./src/index.ts" } }
 *   - Nested ".":        "exports": { ".": "./src/index.ts" }
 * Prefers the "bun" condition, then "import", then "default".
 */
function resolveExportsEntry(pkg: Record<string, unknown>): string | null {
  const exports = pkg.exports;
  if (!exports) return null;

  // String shorthand: "exports": "./src/index.ts"
  if (typeof exports === "string") return exports;

  if (typeof exports !== "object" || Array.isArray(exports)) return null;
  const exportsObj = exports as Record<string, unknown>;

  // "exports": { ".": ... }
  const dot = exportsObj["."];
  if (!dot) return null;

  // "exports": { ".": "./src/index.ts" }
  if (typeof dot === "string") return dot;

  if (typeof dot !== "object" || Array.isArray(dot)) return null;
  const conditions = dot as Record<string, unknown>;

  // Prefer bun > import > default
  for (const key of ["bun", "import", "default"]) {
    if (typeof conditions[key] === "string") return conditions[key] as string;
  }

  return null;
}
```

Note: `fileExists` is a new shared utility (see `src/workflows/utils.ts` changes below).

#### Plugin export resolution

A module may export multiple values. Relying on `Object.values(mod).find(v => typeof v === "function")` picks an arbitrary function — it could be a helper, not the plugin.

Additionally, some plugins may export the hooks object directly (e.g. `export default { config: async (config) => {...} }`) rather than a factory function. `resolvePluginExport` handles both cases: it first looks for a factory function, then falls back to checking if an export is already a hooks object (a plain object with a `config` function property).

```typescript
type PluginExport =
  | { kind: "factory"; fn: Function }
  | { kind: "hooks"; hooks: { config: Function } };

function resolvePluginExport(mod: Record<string, unknown>): PluginExport | null {
  // --- Factory function resolution ---

  // Default export is the strongest signal
  if (typeof mod.default === "function") {
    return { kind: "factory", fn: mod.default };
  }

  const exportedFns = Object.entries(mod)
    .filter(([, v]) => typeof v === "function") as [string, Function][];

  // Single function export — unambiguous
  if (exportedFns.length === 1) {
    return { kind: "factory", fn: exportedFns[0][1] };
  }

  // Multiple function exports — pick the one named *Plugin
  if (exportedFns.length > 1) {
    const pluginExport = exportedFns.find(([name]) =>
      name.toLowerCase().endsWith("plugin"),
    );
    if (pluginExport) return { kind: "factory", fn: pluginExport[1] };
  }

  // --- Hooks object resolution (non-function exports) ---

  // Default export could be a pre-built hooks object
  if (isHooksObject(mod.default)) {
    return { kind: "hooks", hooks: mod.default };
  }

  // Named export that looks like a hooks object
  const hookExports = Object.values(mod).filter(isHooksObject);
  if (hookExports.length === 1) {
    return { kind: "hooks", hooks: hookExports[0] };
  }

  // Can't disambiguate
  return null;
}

function isHooksObject(
  value: unknown,
): value is { config: Function } {
  return (
    typeof value === "object" &&
    value !== null &&
    !Array.isArray(value) &&
    typeof (value as Record<string, unknown>).config === "function"
  );
}
```

#### Deep proxy for mock context

The mock context must handle arbitrarily deep property chains (e.g. `ctx.client.api.listTools()`) without crashing on intermediate access. A recursive proxy returns another proxy for every `get`, and throws with a clear message only when something is *called*.

```typescript
function buildDeepProxy(errorMsg: string): unknown {
  const handler: ProxyHandler<Function> = {
    get: (_target, prop) => {
      // Allow type coercion to work
      if (prop === Symbol.toPrimitive || prop === "toString" || prop === "valueOf") {
        return () => errorMsg;
      }
      return buildDeepProxy(errorMsg);
    },
    apply: () => {
      throw new Error(errorMsg);
    },
  };
  return new Proxy(function () {}, handler);
}
```

#### Timeout

If a plugin's init function hangs (e.g. waiting on a network resource), `detectMcps` should not block `hugo build` forever. Wrap the plugin execution in a `Promise.race` with a 5-second deadline. The timer must be cleaned up on success to prevent it from keeping the process alive:

```typescript
const DETECT_TIMEOUT_MS = 5_000;

async function detectMcpsWithTimeout(
  projectDir: string,
  pkg: Record<string, unknown>,
): Promise<string[]> {
  let timer: ReturnType<typeof setTimeout>;
  const timeout = new Promise<never>((_, reject) => {
    timer = setTimeout(
      () => reject(new Error("MCP detection timed out")),
      DETECT_TIMEOUT_MS,
    );
  });
  try {
    return await Promise.race([detectMcps(projectDir, pkg), timeout]);
  } finally {
    clearTimeout(timer!);
  }
}
```

**Why this works for the common case:**

- Workflow plugins are typically simple — they read files, build config objects, and register them. No network calls, no SDK usage during init.
- Bun can import TypeScript directly, so no compilation step is needed.
- The deep proxy mocks mean the plugin can *reference* `ctx.client`, `ctx.client.api`, etc. without crashing — it only throws if it actually *calls* something.
- The config hook receives a plain object and mutates it. We just read what was mutated.

**Graceful degradation:**

If the plugin does something that requires runtime context (SDK calls, shell commands, network requests), the Proxy traps throw, we catch the error, and `hugo build` warns:

```
Warning: Could not auto-detect MCP servers — plugin uses runtime APIs during init.
  Declare them manually in package.json under "hugo.mcps":
  { "hugo": { "mcps": ["server-name-1", "server-name-2"] } }
```

The `package.json` `hugo.mcps` field is the escape hatch for plugins that can't be statically executed.

### Fallback: manual declaration in `package.json`

For plugins whose init function requires runtime context, authors declare MCP names in `package.json`:

```json
{
  "name": "@org/my-workflow",
  "hugo": {
    "mcps": ["websearch", "context7"]
  }
}
```

`hugo build` checks this field first. If present, it uses the declared names and skips plugin execution. If absent, it attempts plugin execution. This means:

1. If `package.json` has `hugo.mcps` -> use it (no plugin execution)
2. If `package.json` does not have `hugo.mcps` -> attempt plugin execution
3. If plugin execution fails -> warn and produce an empty `mcps` array

### Manifest and state changes

**`WorkflowManifest` adds `mcps`:**

```typescript
export type WorkflowManifest = {
  agents: string[];
  commands: string[];
  skills: string[];
  mcps: string[];  // new
};
```

**`WorkflowEntry` adds `mcps`:**

```typescript
export type WorkflowEntry = {
  package: string;
  version: string;
  agents: string[];
  commands: string[];
  skills: string[];
  mcps: string[];  // new
};
```

**`workflow.json` output:**

```json
{
  "agents": ["reviewer"],
  "commands": ["review"],
  "skills": ["analysis"],
  "mcps": ["context7", "websearch"]
}
```

**Cached state in `opencode.json`:**

```json
{
  "hugo": {
    "workflows": {
      "code-review": {
        "package": "@org/code-review",
        "version": "1.0.0",
        "agents": ["reviewer"],
        "commands": ["review"],
        "skills": ["analysis"],
        "mcps": ["context7", "websearch"]
      }
    }
  }
}
```

### Empty-content validation

A workflow that provides only MCP servers (no agents, commands, or skills) is valid. The existing empty-content check in `build()` becomes:

```typescript
if (agents.length === 0 && commands.length === 0 && skills.length === 0 && mcps.length === 0) {
  throw new Error("No agents, commands, skills, or MCP servers found. Nothing to build.");
}
```

## Changes Required

### `src/workflows/types.ts`

- Add `mcps: string[]` to `WorkflowManifest`
- Add `mcps: string[]` to `WorkflowEntry`

No changes to `CollisionWarning` — MCP naming overlaps are benign (see "Why MCPs don't need collision detection" above).

### `src/workflows/manifest.ts`

- Parse `mcps` field in `parseManifest` (same pattern as existing fields — optional string array, default `[]`)

### `src/workflows/utils.ts`

- Export a `fileExists(path: string): Promise<boolean>` utility function (stat-based, returns false on error). This is needed by `resolveSourceEntry` in `build.ts`. The same pattern already exists privately in `collisions.ts` (`fileExistsSafe`) and `tests/helpers.ts` (`fileExists`) — consolidate into the shared utility module.

### `src/commands/build.ts`

- Import `fileExists` from `../workflows/utils`
- Add `resolveExportsEntry(pkg)` function — extracts the `"."` entry point from the `exports` field, preferring `bun` > `import` > `default` conditions
- Add `resolveSourceEntry(projectDir, pkg)` function — probes for source entry point files (checks `source`, then `exports`, then hardcoded candidates, then `main`/`module`)
- Add `isHooksObject(value)` type guard — checks if a value is a plain object with a `config` function property
- Add `resolvePluginExport(mod)` function — returns `{ kind: "factory", fn }` or `{ kind: "hooks", hooks }`. Tries function resolution first (default export → single function → `*Plugin` named function), then hooks object resolution (default export → single matching export)
- Add `buildDeepProxy(errorMsg)` function — recursive proxy for mock context
- Add `detectMcps(projectDir, pkg)` function — executes plugin with mock context (or uses hooks object directly), returns MCP key names. Receives already-parsed `packageJson` from `build()` to avoid re-reading the file.
- Add `detectMcpsWithTimeout(projectDir, pkg)` — wraps `detectMcps` in a `Promise.race` with 5-second deadline and `clearTimeout` cleanup
- Add `readPackageJsonMcps(packageJson)` function — reads `hugo.mcps` from the already-parsed package.json object
- Update `build()` to resolve MCPs (package.json first, then plugin execution with timeout, then empty `[]` on failure). Pass the already-parsed `packageJson` to both `readPackageJsonMcps` and `detectMcpsWithTimeout`. Detection failure is caught and pushed to the existing `warnings` array — `handleBuild` in `cli.ts` already prints warnings, so no additional CLI logic is needed:
  ```typescript
  let mcps: string[];
  const declaredMcps = readPackageJsonMcps(packageJson);
  if (declaredMcps) {
    mcps = declaredMcps;
  } else {
    try {
      mcps = await detectMcpsWithTimeout(projectDir, packageJson);
    } catch (err) {
      warnings.push(
        `Could not auto-detect MCP servers: ${errorMessage(err)}. ` +
        `Declare them in package.json under "hugo.mcps".`,
      );
      mcps = [];
    }
  }
  ```
- Include `mcps` in the constructed `WorkflowManifest` object: `const manifest: WorkflowManifest = { agents, commands, skills, mcps }`
- The existing `JSON.stringify(manifest, null, 2)` handles `mcps` in the `workflow.json` output automatically
- Add `mcps` to `BuildResult`:
  ```typescript
  export type BuildResult = {
    agents: string[];
    commands: string[];
    skills: string[];
    mcps: string[];      // new
    warnings: string[];
  };
  ```
- Update the empty-content check: add `mcps.length === 0` to the condition so a workflow providing only MCPs is valid
- Add `checkDuplicates(mcps, "mcps")` call alongside the existing duplicate checks. Note: this is only meaningful for the `hugo.mcps` package.json path — `Object.keys()` from plugin detection is inherently unique. Add a comment to that effect.

### `src/commands/install.ts`

- Include `manifest.mcps` when constructing `WorkflowEntry` (line 150-156)
- Include `mcps` in `InstallResult` type and return value

### `src/commands/update.ts`

- Add `addedMcps: string[]` and `removedMcps: string[]` to `WorkflowUpdateDetail`
- Add `mcps` to the `manifestChanged` comparison: `!arraysEqual(newManifest.mcps, target.entry.mcps)`
- Include `mcps` in the fallback manifest when `workflow.json` can't be read after update (line 106-111)
- Include `mcps` in the `setWorkflow` call (line 122-128)

### `src/commands/list.ts`

- Add `mcps: string[]` to `WorkflowListEntry`
- Include `mcps` from cached state in both the single-workflow and all-workflows code paths

### `src/commands/remove.ts`

- Add `mcps: string[]` to `RemoveResult` for consistency with other result types
- Include `entry.mcps` in the return value

### `src/cli.ts`

- Update `formatCount` signature to accept MCPs: `formatCount(agents, commands, skills, mcps)`. Include `N mcp(s)` in output when mcps is non-empty. This is a required parameter — all call sites must be updated.
- Update all 4 `formatCount` call sites to pass `mcps`:
  - `handleInstall` (line 150): pass `result.mcps`
  - `handleRemove` (line 171): pass `result.mcps`
  - `handleEnable` (line 243): pass `w.entry.mcps`
  - `handleBuild` (line 398): pass `result.mcps`
- Update `handleList` to display MCPs in the workflow detail block (same pattern as agents/commands/skills)
- Update `handleBuild` — build warnings from MCP detection are already handled by the existing warning-printing loop (lines 394-396)
- Update `handleUpdate` to display added/removed MCPs in the change summary

No changes needed to `handleHealth` or `handleSwitch` — MCPs don't participate in collision detection.

### Files NOT changed

- **`src/workflows/collisions.ts`** — MCPs don't need collision detection. Refactor: replace its private `fileExistsSafe` with the new shared `fileExists` from `utils.ts`.
- **`src/commands/health.ts`** — no MCP-specific health checks
- **`src/commands/enable.ts`** — the `detectCollisions` call site destructures `agents/commands/skills` explicitly and doesn't need MCPs
- **`src/commands/disable.ts`** — only reads `entry.package` for plugin array removal, no manifest field access
- **`src/commands/switch.ts`** — same as `enable.ts`

### Existing tests that need updating

Adding `mcps` to the type system and manifest parsing changes the shape of objects across the codebase. The following existing tests will break and must be updated alongside the implementation:

**Phase 1 breakage (types + manifest parsing):**

- `tests/unit/manifest.test.ts` — every `expect(result).toEqual(...)` assertion needs `mcps: []` added to the expected object (lines 17-21, 26, 31-35, 39-43, 46-49). The "parses full manifest" test needs a case with `mcps` present.
- `tests/unit/config.test.ts` — the `sampleEntry` constant (line 35-41) lacks `mcps`. Every test using `toEqual(sampleEntry)` will fail. Add `mcps: []` (or a non-empty array for some cases) to `sampleEntry`.

**Phase 2 breakage (build command):**

- `tests/integration/build.test.ts`:
  - Line 285-289: `expect(Object.keys(manifest).sort()).toEqual(["agents", "commands", "skills"])` -> needs `"mcps"` added.
  - Lines 170-173, 181-182: error message changes from `"No agents, commands, or skills found"` to `"No agents, commands, skills, or MCP servers found"`.
- `tests/integration/cli.test.ts`:
  - Line 494: same error message change.

**Phase 3 breakage (install/update/list):**

- `tests/integration/install.test.ts` — assertions should be extended to verify `result.mcps` (e.g., `expect(result.mcps).toEqual([])`).
- `tests/integration/list.test.ts` — extend assertions to verify `mcps` field in list entries.
- `tests/integration/update.test.ts` — extend assertions to verify `addedMcps`/`removedMcps`.

**Fixture updates:**

Existing fixture `workflow.json` files do not need `"mcps": []` added — `parseManifest` defaults missing fields to `[]`, which is the correct contract. Leaving them as-is also exercises the default-handling path in tests.

### New tests

**Unit tests:**

- `manifest.test.ts` — add cases for `mcps` field: present, absent, invalid, duplicates
- `config.test.ts` — verify `mcps` is preserved in workflow state read/write

**Integration tests:**

- `build.test.ts` — test MCP detection via plugin execution, fallback to `package.json`, graceful failure when plugin needs runtime context, timeout behavior, entry point resolution, plugin export resolution
- `install.test.ts` — verify `mcps` appears in cached state after install
- `list.test.ts` — verify `mcps` appears in list output
- `update.test.ts` — verify `mcps` changes are detected and reported

**Test fixtures:**

- Add a fixture workflow package with a plugin entry point that registers MCPs via config hook (factory function pattern)
- Add a fixture workflow package that exports a hooks object directly (non-function export, e.g. `export default { config: async (config) => {...} }`)
- Add a fixture workflow package with `hugo.mcps` in `package.json` (manual declaration)
- Add a fixture workflow package with a plugin that uses runtime APIs (to test graceful degradation)
- Add a fixture workflow package with multiple exported functions (to test plugin export resolution)
- Add a fixture workflow package with an `exports` field in package.json (to test `resolveExportsEntry`)

## Implementation Order

### Phase 1: Types and manifest parsing

1. Update `WorkflowManifest` and `WorkflowEntry` types
2. Update `parseManifest` to handle `mcps` field
3. Add `fileExists` to `src/workflows/utils.ts`
4. Update `sampleEntry` in `config.test.ts` and expected objects in `manifest.test.ts`
5. Unit tests for manifest parsing with mcps — run tests to confirm green

### Phase 2: Build command — MCP detection

6. Implement helper functions: `resolveExportsEntry`, `resolveSourceEntry`, `isHooksObject`, `resolvePluginExport`, `buildDeepProxy`
7. Implement `readPackageJsonMcps()` and `detectMcps()` / `detectMcpsWithTimeout()` in `build.ts`
8. Update `build()` to include mcps in manifest generation (with timeout, empty-content check update, warning push on failure)
9. Update `build.test.ts` existing assertions (manifest keys, error message text)
10. Update `cli.test.ts` build error message assertion
11. Create test fixtures (workflow with plugin entry point, workflow with package.json declaration, workflow with runtime-dependent plugin, workflow with multiple exports, workflow exporting hooks object directly)
12. New integration tests for build with MCP detection

### Phase 3: Install, update, list, remove — state propagation

13. Update `install.ts` to include `mcps` in `WorkflowEntry` and `InstallResult`
14. Update `update.ts` to refresh `mcps` from updated manifests, add `addedMcps`/`removedMcps`
15. Update `list.ts` to include `mcps` in `WorkflowListEntry`
16. Update `remove.ts` to include `mcps` in `RemoveResult`
17. Extend existing integration test assertions to cover `mcps` field
18. New integration tests for install/update/list/remove with mcps

### Phase 4: CLI output

19. Update `formatCount` signature and all 4 call sites (`handleInstall`, `handleRemove`, `handleEnable`, `handleBuild`)
20. Update `handleList` to display MCPs
21. Update `handleUpdate` to display added/removed MCPs
22. CLI tests for new output

## Related: Hugo's own MCP servers

Hugo currently hardcodes three MCP servers (Exa/Tavily websearch, Context7, grep.app) in `src/index.ts` via `createBuiltinMcps()`. These should eventually move to a separate first-party workflow package (e.g., `@happily-dev/essentials`) so Hugo itself is a pure workflow manager. That migration is out of scope for this plan but is the intended direction.

## Decisions

1. **`hugo build` does not require a plugin entry point.** Workflows without entry points still build fine — `mcps` defaults to `[]`. MCP detection is optional and additive. If no entry point is found and no `hugo.mcps` is declared, the workflow simply has an empty `mcps` array.

2. **A workflow providing only MCPs is valid.** The empty-content check allows workflows that have no agents, commands, or skills but do provide MCP servers.

3. **Mock config limitations are accepted.** The mock config starts empty. If a plugin conditionally registers MCPs based on existing config state, the mock may produce different results than runtime. The `package.json` `hugo.mcps` fallback covers this case. The mock config is typed as `Record<string, unknown>` rather than the SDK's `Config` type — this works at runtime because plugins mutate properties on the object, and JavaScript doesn't enforce TypeScript types at runtime.

4. **Module import cache-busting.** `detectMcps` appends a timestamp query parameter to the import path (`?t=<timestamp>`) to bypass the module cache. Without this, dynamic `import()` returns cached modules, which breaks test isolation and would return stale results if a workflow's source code changed between builds in the same process.
